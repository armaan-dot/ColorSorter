{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor MotorLeft = motor(PORT7, false);\nmotor MotorRight = motor(PORT12, true);\noptical OpticalSensor = optical(PORT3);\nmotor MotorGrabber = motor(PORT2, false);\nmotor MotorElevator = motor(PORT6, false);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n// Converts a color to a string\nconst char* convertColorToString(color col) {\n  if (col == colorType::red) return \"red\";\n  else if (col == colorType::green) return \"green\";\n  else if (col == colorType::blue) return \"blue\";\n  else if (col == colorType::white) return \"white\";\n  else if (col == colorType::yellow) return \"yellow\";\n  else if (col == colorType::orange) return \"orange\";\n  else if (col == colorType::purple) return \"purple\";\n  else if (col == colorType::cyan) return \"cyan\";\n  else if (col == colorType::black) return \"black\";\n  else if (col == colorType::transparent) return \"transparent\";\n  else if (col == colorType::red_violet) return \"red_violet\";\n  else if (col == colorType::violet) return \"violet\";\n  else if (col == colorType::blue_violet) return \"blue_violet\";\n  else if (col == colorType::blue_green) return \"blue_green\";\n  else if (col == colorType::yellow_green) return \"yellow_green\";\n  else if (col == colorType::yellow_orange) return \"yellow_orange\";\n  else if (col == colorType::red_orange) return \"red_orange\";\n  else if (col == colorType::none) return \"none\";\n  else return \"unknown\";\n}\n\n\n// Convert colorType to string\nconst char* convertColorToString(colorType col) {\n  if (col == colorType::red) return \"red\";\n  else if (col == colorType::green) return \"green\";\n  else if (col == colorType::blue) return \"blue\";\n  else if (col == colorType::white) return \"white\";\n  else if (col == colorType::yellow) return \"yellow\";\n  else if (col == colorType::orange) return \"orange\";\n  else if (col == colorType::purple) return \"purple\";\n  else if (col == colorType::cyan) return \"cyan\";\n  else if (col == colorType::black) return \"black\";\n  else if (col == colorType::transparent) return \"transparent\";\n  else if (col == colorType::red_violet) return \"red_violet\";\n  else if (col == colorType::violet) return \"violet\";\n  else if (col == colorType::blue_violet) return \"blue_violet\";\n  else if (col == colorType::blue_green) return \"blue_green\";\n  else if (col == colorType::yellow_green) return \"yellow_green\";\n  else if (col == colorType::yellow_orange) return \"yellow_orange\";\n  else if (col == colorType::red_orange) return \"red_orange\";\n  else if (col == colorType::none) return \"none\";\n  else return \"unknown\";\n}\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       Group 20                                                 \n//    Created:      {date}                                                    \n//    Description:  Color Sorting                                              \n//                                                                            \n//---------------------------------------------------------------------------\n#include \"iq_cpp.h\"\nusing namespace vex;\nfloat kP = 0.45; //cannot be here, global variable not allowed\nfloat kI = 0.0;\nfloat kD = 0.0;\nvoid turnPID(float targetAngle)\n{\n  float err;\n  float prevErr = 0;\n  float integral = 0;\n  const float dt = 0.02; // 20 ms\n\n  while(true)\n  {\n    float current = BrainInertial.rotation(degrees);\n    err = targetAngle - current;\n\n    integral += err * dt;\n\n    float power = kP * err;\n\n    // Max clamp\n    if(power > 60) power = 60;\n    if(power < -60) power = -60;\n\n    // Minimum power if not very close yet\n    float minPower = 12;\n    if (fabs(err) > 3.0) \n    {\n    if(power > 0 && power < minPower)  power = minPower;\n    if(power < 0 && power > -minPower) power = -minPower;\n    }\n\n    if(fabs(err) < 1.0)\n      break;\n\n    MotorLeft.spin(forward, power, percent);\n    MotorRight.spin(reverse, power, percent);\n\n    prevErr = err;\n    wait(20, msec);\n  }\n\n  MotorLeft.stop();\n  MotorRight.stop();\n}\n\nbool checkAndGrab(int& ObjColour)\n{\n  if(OpticalSensor.isNearObject())\n  {\n    ObjColour = colorCheck();\n    MotorLeft.stop();\n    MotorRight.stop();\n    wait(1,seconds);\n    MotorGrabber.spin(forward);\n    wait(1,seconds);\n    MotorGrabber.stop(brake);\n    MotorGrabber.stop(hold);\n    return true;\n\n  }\n  else\n  {\n    return false;\n  }\n}\n\nvoid elevObject (int motorpower, int position) \n{\n  MotorElevator.setPosition(0,turns);\n  MotorElevator.setVelocity(motorpower, percent);\n  MotorElevator.spin(forward);\n\n  while (MotorElevator.position(turns)<position){}\n  MotorElevator.stop(hold);\n\n  MotorGrabber.setVelocity(motorpower,percent);\n  MotorGrabber.spin(reverse);\n}\n\nvoid returnHome(float X_pos,float Y_pos,bool direction){\n       if(direction == true){   //Turn towards the base\n         turnPID (90);\n       }\n       else if (direction == false){ \n         turnPID (-90);\n       }\n\n       MotorLeft.setPosition(0,turns);  // Moves forward the base\n       MotorRight.spin(forward);\n       MotorLeft.spin(forward);\n      while(MotorLeft.position(turns) < X_pos){}\n      MotorRight.stop(brake);\n      MotorLeft.stop(brake);\n\n      if(direction == true){   //Turn towards the base\n         turnPID (180);\n       }\n       else if (direction == false){ \n         turnPID (-180);\n       }\n\n       MotorLeft.setPosition(0,turns);    // To reach the home base\n       MotorRight.spin(forward);\n       MotorLeft.spin(forward);\n      while(MotorLeft.position(turns) < Y_pos){}\n      MotorRight.stop(brake);\n      MotorLeft.stop(brake);\n      wait(3, seconds);\n}\n\nint main() \n{\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n\n  // Begin project code\n  //Touch Led :: To start\n  bool turnCheck = true;\n  float x_pos = 0;\n  float y_pos = 0;\n  float final_pos =0;\n  float ObjColour = 0; \n  \n  MotorLeft.setVelocity(70,percent);\n  MotorRight.setVelocity(70,percent);\n  MotorElevator.setVelocity(70,percent);\n  OpticalSensor.setLight(ledState::on);\n  while (x_pos < 3.8 && y_pos > -0.5)\n  {\n    Brain.Screen.newLine();\n    Brain.Screen.print(\"%f\", final_pos);\n\n    bool grabbed = false;\n  \n    //while(grabbed == false)\n    //{\n      MotorLeft.setPosition(0,turns);\n      MotorLeft.spin(forward);\n      MotorRight.spin(forward);\n\n\n      while (MotorLeft.position(turns) <= 3.95 && grabbed==false)\n      {\n        grabbed = checkAndGrab();\n      }\n\n      float distanceTraveled_y = MotorLeft.position(turns);//keep track of y_position in these three lines \n      if (turnCheck) y_pos = distanceTraveled_y;\n      else y_pos = 0;\n\n      if (grabbed == false)\n      {\n        MotorLeft.stop();\n        MotorRight.stop();\n        BrainInertial.setRotation(0,degrees);\n        if (turnCheck)\n        {\n          //Brain.Screen.print(\"%f\", y_pos);\n          //wait(1,seconds);\n          turnPID(90);\n          MotorLeft.setPosition(0,turns);\n          MotorLeft.spin(forward);\n          MotorRight.spin(forward);\n          while(MotorLeft.position(turns) <= 0.75)\n          {\n          }\n          float distanceTraveled_x = MotorLeft.position(turns);//keep track of y_position in these three lines \n          x_pos += distanceTraveled_x;\n          Brain.Screen.newLine();\n          Brain.Screen.print(\"%f\", x_pos);\n          wait(1,seconds);\n       \n          turnPID(180);\n          turnCheck = false;\n        }\n        else if (!turnCheck)\n        {\n          Brain.Screen.newLine();\n          //Brain.Screen.print(\"%f\", y_pos);\n         // wait(1,seconds);\n          turnPID(-90);\n          MotorLeft.setPosition(0,turns);\n          MotorLeft.spin(forward);\n          MotorRight.spin(forward);\n          while(MotorLeft.position(turns) <= 0.75)\n          {}\n          float distanceTraveled_x = MotorLeft.position(turns);\n          x_pos += distanceTraveled_x;\n          //Brain.Screen.newLine();\n          //Brain.Screen.print(\"%f\", x_pos);\n          //wait(1,seconds);\n\n          turnPID(-180);\n          turnCheck = true;\n        }\n      }\n      else \n      {\n           //Brain.Screen.newLine();\n           //Brain.Screen.print(\"%f\", y_pos);\n           //wait(1,seconds);\n            MotorElevator.spin(forward);\n            wait(1, seconds);\n            MotorElevator.stop(hold);\n            returnHome(x_pos,y_pos,turnCheck);\n            MotorLeft.stop(brake);\n            MotorRight.stop(brake);\n\n            wait(1,seconds);\n\n            MotorLeft.spin(brake);\n            MotorRight.spin(brake);\n            MotorLeft.setPosition(0,turns);\n            while(MotorLeft.position(turns) > 0.5 ){}\n            MotorLeft.stop(brake);\n            MotorRight.stop(brake);\n\n            colorCheckBin(ObjectColor);\n            dropping (50);\n\n            turnPID(0);\n\n            MotorLeft.spin(brake);\n            MotorRight.spin(brake);\n            MotorLeft.setPosition(0,turns);\n            while(MotorLeft.position(turns) > 0.5 ){}\n            MotorLeft.stop(brake);\n            MotorRight.stop(brake);\n\n\n      }\n        \n  }\n}","textLanguage":"cpp","robotConfig":[{"port":[7],"name":"MotorLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"MotorRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[3],"name":"OpticalSensor","customName":true,"deviceType":"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22},{"port":[2],"name":"MotorGrabber","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"MotorElevator","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}