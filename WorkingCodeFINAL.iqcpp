{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor MotorLeft = motor(PORT7, false);\nmotor MotorRight = motor(PORT12, true);\noptical OpticalSensor = optical(PORT3);\nmotor MotorGrabber = motor(PORT2, false);\nmotor MotorElevator = motor(PORT6, false);\ndistance Distance1 = distance(PORT1);\ntouchled touchSensor = touchled(PORT8);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\n// Converts a color to a string\nconst char* convertColorToString(color col) {\n  if (col == colorType::red) return \"red\";\n  else if (col == colorType::green) return \"green\";\n  else if (col == colorType::blue) return \"blue\";\n  else if (col == colorType::white) return \"white\";\n  else if (col == colorType::yellow) return \"yellow\";\n  else if (col == colorType::orange) return \"orange\";\n  else if (col == colorType::purple) return \"purple\";\n  else if (col == colorType::cyan) return \"cyan\";\n  else if (col == colorType::black) return \"black\";\n  else if (col == colorType::transparent) return \"transparent\";\n  else if (col == colorType::red_violet) return \"red_violet\";\n  else if (col == colorType::violet) return \"violet\";\n  else if (col == colorType::blue_violet) return \"blue_violet\";\n  else if (col == colorType::blue_green) return \"blue_green\";\n  else if (col == colorType::yellow_green) return \"yellow_green\";\n  else if (col == colorType::yellow_orange) return \"yellow_orange\";\n  else if (col == colorType::red_orange) return \"red_orange\";\n  else if (col == colorType::none) return \"none\";\n  else return \"unknown\";\n}\n\n\n// Convert colorType to string\nconst char* convertColorToString(colorType col) {\n  if (col == colorType::red) return \"red\";\n  else if (col == colorType::green) return \"green\";\n  else if (col == colorType::blue) return \"blue\";\n  else if (col == colorType::white) return \"white\";\n  else if (col == colorType::yellow) return \"yellow\";\n  else if (col == colorType::orange) return \"orange\";\n  else if (col == colorType::purple) return \"purple\";\n  else if (col == colorType::cyan) return \"cyan\";\n  else if (col == colorType::black) return \"black\";\n  else if (col == colorType::transparent) return \"transparent\";\n  else if (col == colorType::red_violet) return \"red_violet\";\n  else if (col == colorType::violet) return \"violet\";\n  else if (col == colorType::blue_violet) return \"blue_violet\";\n  else if (col == colorType::blue_green) return \"blue_green\";\n  else if (col == colorType::yellow_green) return \"yellow_green\";\n  else if (col == colorType::yellow_orange) return \"yellow_orange\";\n  else if (col == colorType::red_orange) return \"red_orange\";\n  else if (col == colorType::none) return \"none\";\n  else return \"unknown\";\n}\n\n\nvoid vexcodeInit() {\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       Group 20                                                 \n//    Created:      {date}                                                    \n//    Description:  Color Sorting                                              \n//                                                                            \n//---------------------------------------------------------------------------\n#include \"iq_cpp.h\"\nusing namespace vex;\n\n\nvoid configureAllSensors(){\n  BrainInertial.calibrate();\n  wait(2,seconds);\n  BrainInertial.setHeading(0,degrees);\n  BrainInertial.setRotation(0,degrees);\n  MotorLeft.setPosition(0,turns);\n  MotorRight.setPosition(0,turns);\n  Brain.Screen.clearScreen();\n  Brain.Screen.setFont(mono15);\n  OpticalSensor.setLight(ledState::on);\n}\n\nvoid turnPID(float relativeAngle)\n{\n    const float kP = 1.2;\n    const float kI = 0.0;\n    const float kD = 0.15;\n\n    const float dt = 0.02; // 20 ms\n    const float tolerance = 1.0; \n    const float settleTime = 0.20;\n\n    float startAngle = BrainInertial.rotation(degrees);\n    float target = startAngle + relativeAngle;\n\n    float error = 0;\n    float prevError = 0;\n    float integral = 0;\n\n    float stableCounter = 0;\n    bool done = false;\n\n    while (!done)\n    {\n        float current = BrainInertial.rotation(degrees);\n        error = target - current;\n\n        integral += error * dt;\n        float derivative = (error - prevError) / dt;\n        prevError = error;\n\n        float power = kP * error + kI * integral + kD * derivative;\n\n        if(power > 60) power = 60;\n        if(power < -60) power = -60;\n\n        float minPower = 8;\n        if (fabs(error) > 3.0)\n        {\n            if(power > 0 && power < minPower) power = minPower;\n            if(power < 0 && power > -minPower) power = -minPower;\n        }\n\n        MotorLeft.spin(forward,  power, percent);\n        MotorRight.spin(forward, -power, percent);\n\n        if (fabs(error) <= tolerance)\n            stableCounter += dt;\n        else\n            stableCounter = 0;\n\n        if (stableCounter >= settleTime)\n            done = true;\n\n        wait(dt, seconds);\n    }\n\n    MotorLeft.stop(brake);\n    MotorRight.stop(brake);\n}\n\nfloat colorCheck() // Author : Armaandeep Singh \n{\n  int hue = OpticalSensor.hue();\n    // Get the color det ected \n   if (hue >= 70 && hue <= 130) //hue values for green\n   {\n      return 3.0;\n    } \n    //hue value: Blue = (190–250)\n    else if (hue >= 140 && hue <= 250)\n    {\n      return 2.0;\n    }\n    //hue value: Orange = (190–250)\n    else if (hue >=0 && hue <=40)\n    {\n      return 1.0;\n    }\n    // Wrong Color Detected\n    else \n    {\n      return 67.0;\n    }\n}\n\nbool checkAndGrab(float& ObjColour)\n{\n  if(OpticalSensor.isNearObject() && Distance1.objectDistance(mm)< 55)\n  {\n    ObjColour = colorCheck();\n    MotorLeft.stop();\n    MotorRight.stop();\n    wait(1,seconds);\n    MotorGrabber.spin(forward);\n    wait(1,seconds);\n    MotorGrabber.stop(brake);\n    MotorGrabber.stop(hold);\n    return true;\n\n  }\n  else\n  {\n    return false;\n  }\n}\n\nvoid elevObject (int motorpower, int position) \n{\n  MotorElevator.setPosition(0,turns);\n  MotorElevator.setVelocity(motorpower, percent);\n  MotorElevator.spin(forward);\n\n  while (MotorElevator.position(turns)<position){}\n  MotorElevator.stop(hold);\n\n  MotorGrabber.setVelocity(motorpower,percent);\n  MotorGrabber.spin(reverse);\n}\n\nvoid returnHome(float X_pos,float Y_pos,bool turnCheck){\n  if (turnCheck == true){\n    turnPID(-90);\n  }\n  else if (turnCheck == false)\n  {\n    turnPID(90);\n  }\n // Brain.Screen.newLine();\n  //Brain.Screen.print(\"%f\", X_pos);\n  MotorLeft.setPosition(0,turns);  // Moves forward the base\n  MotorRight.spin(forward);\n  MotorLeft.spin(forward);\n\n  while(MotorLeft.position(turns) < X_pos)\n  {}\n  MotorRight.stop(brake);\n  MotorLeft.stop(brake);\n\n  if (turnCheck == true)\n  {\n    turnPID(-90);\n  }\n  else if (turnCheck == false)\n  {\n    turnPID(-90);\n  }\n\n  MotorLeft.setPosition(0,turns);    // To reach the home base\n  MotorRight.spin(forward);\n  MotorLeft.spin(forward);\n  while(MotorLeft.position(turns) < Y_pos){}\n  MotorRight.stop(brake);\n  MotorLeft.stop(brake);\n  wait(1, seconds);\n}\n\nvoid dropping (int motorpower, float &x ) //code changed\n{\n float dis = MotorLeft.position(turns);\n MotorLeft.spin(forward);\n MotorRight.spin(forward);\n\n while(OpticalSensor.isNearObject() == 0 || Distance1.objectDistance(mm) >15){}\n // wait(0.5,seconds);\n MotorLeft.stop(brake);\n MotorRight.stop(brake);\n\n  MotorGrabber.spin(reverse);\n  wait(1.5, seconds);\n  MotorGrabber.stop(brake);\n  MotorGrabber.stop(hold);\n  \n  MotorLeft.spin(reverse);\n  MotorRight.spin(reverse);\n  while(MotorLeft.position(turns) > dis){}\n  MotorLeft.stop();\n  MotorRight.stop();\n\n}\n\n float colorCheckBin(float &ObjColor, float &x)\n{\n float BinColor = 0;\n\n//   x = MotorLeft.position(turns);\n//  MotorLeft.spin(forward);\n//  MotorRight.spin(forward);\n\n//  while(OpticalSensor.isNearObject() == 0 && Distance1.objectDistance(mm) >15){}\n// //  wait(0.5,seconds);\n//  MotorLeft.stop(brake);\n//  MotorRight.stop(brake);\n\n BinColor = colorCheck();\n\n if(BinColor == ObjColor) {\n  Brain.Screen.print(\"orange\");\n  return 1.0;\n }\n\n//  MotorLeft.spin(reverse);\n//  MotorRight.spin(reverse);\n//  while(MotorLeft.position(turns) > x){}\n//  MotorLeft.stop();\n//  MotorRight.stop();\n\n turnPID(90);\n//  x = MotorLeft.position(turns);\n//  MotorLeft.spin(forward);\n//  MotorRight.spin(forward);\n \n//  while(OpticalSensor.isNearObject() == 0 || Distance1.objectDistance(mm) > 15){}\n\n//  // wait(0.5,seconds);\n\n//  MotorLeft.stop(brake);\n//  MotorRight.stop(brake);\n BinColor = colorCheck();\n\n\n if (BinColor == ObjColor) {\n  Brain.Screen.print(\"green\");\n  return 2.0;\n }\n//  MotorLeft.spin(reverse);\n//  MotorRight.spin(reverse);\n//  while(MotorLeft.position(turns) > x){}\n//  MotorLeft.stop();\n//  MotorRight.stop();\n\n turnPID(180);\n \n\n//  x = MotorLeft.position(turns);\n//  MotorLeft.spin(forward);\n//  MotorRight.spin(forward);\n \n//  while(OpticalSensor.isNearObject() == 0 || Distance1.objectDistance(mm) > 15){}\n\n//  // wait(0.5,seconds);\n\n//  MotorLeft.stop(brake);\n//  MotorRight.stop(brake);\n BinColor = colorCheck();\n\n //if(BinColor == 3.0) {\n // Brain.Screen.print(\"blue\");\n  return 3.0;\n// }\n}\n\n\nint main() \n{\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n \n  configureAllSensors();\n  // Begin project code\n  //Touch Led :: To start\n  bool turnCheck = true;\n  bool valid = true;\n  float x_pos = 0;\n  float y_pos = 0;\n  float ObjColour = 0; \n  float x = 0;\n\n  MotorLeft.setVelocity(70,percent);\n  MotorRight.setVelocity(70,percent);\n  MotorElevator.setVelocity(70,percent);\n  OpticalSensor.setLight(ledState::on);\n\n  \n// modification\nwhile (valid == true){\n  while(!touchSensor.pressing()){}\n  while(touchSensor.pressing()){}\n\n  MotorLeft.setPosition(0,turns);\n  MotorLeft.spin(forward);\n  MotorRight.spin(forward);\n\n  while(MotorLeft.position(turns) < 2){}\n  MotorLeft.stop(brake);\n  MotorRight.stop(brake);\n  wait(1,seconds);\n\n  while (x_pos < 7.0 && y_pos>-0.1)\n  {\n\n      bool grabbed = false;\n      MotorRight.setPosition(0,turns);\n      MotorLeft.setPosition(0,turns);\n\n      MotorLeft.spin(forward);\n      MotorRight.spin(forward);\n\n\n      while (MotorLeft.position(turns) <= 3.95 && grabbed==false)\n      {\n        grabbed = checkAndGrab(ObjColour);\n      }\n\n      float distanceTraveled_y = MotorLeft.position(turns);//keep track of y_position in these three lines \n      if (turnCheck) y_pos += distanceTraveled_y;\n      else y_pos -= distanceTraveled_y;\n\n      if (grabbed == false)\n      {\n        MotorLeft.stop();\n        MotorRight.stop();\n        \n        if (turnCheck)\n        {\n          turnPID(90);\n        }\n        else if (!turnCheck)\n        {\n          turnPID(-90);\n        }\n          MotorRight.setPosition(0,turns);\n          MotorLeft.spin(forward);\n          MotorRight.spin(forward);\n          \n          while(MotorRight.position(turns) < 1.5){}\n          float distanceTraveled_x = MotorRight.position(turns);//keep track of x_position in these two lines \n          x_pos += distanceTraveled_x ; \n         \n        if(turnCheck)\n        {\n          turnPID(90);\n          turnCheck = false;\n        }\n        else if(!turnCheck)\n        {\n          turnPID(-90);\n          turnCheck = true;\n        }\n        else return 99999; \n\n      }\n      else \n      {\n          MotorElevator.setPosition(0,turns);\n          MotorElevator.spin(forward);\n          while(MotorElevator.position(turns)<1.1){} \n          MotorElevator.stop(brake);\n          MotorElevator.stop(hold);\n          MotorLeft.stop(hold);\n          MotorRight.stop(hold);\n          \n          \n          float temp = x_pos*0.80;\n           \n          Brain.Screen.print(\"%f \", temp);\n          returnHome(temp,y_pos,turnCheck);\n\n          MotorLeft.setVelocity(10,percent);\n          MotorRight.setVelocity(10,percent);\n           \n          if(BrainInertial.rotation(degrees) < 180){\n          MotorRight.spin(reverse);\n          MotorLeft.spin(forward);\n          while(BrainInertial.rotation(degrees) < 180 ){}\n           \n          MotorLeft.stop();\n          MotorRight.stop();\n          }\n          else if(BrainInertial.rotation(degrees) > 180){\n\n          MotorRight.spin(forward);\n          MotorLeft.spin(reverse);\n          while(BrainInertial.rotation(degrees) > 180 ){}\n           \n          MotorLeft.stop();\n          MotorRight.stop();\n          }\n      \n          MotorLeft.setVelocity(70,percent);\n          MotorRight.setVelocity(70,percent);\n\n          \n\n          MotorLeft.stop(brake);\n          MotorRight.stop(brake);\n\n\n          wait(0.5,seconds);\n\n\n// // modifications BrainInertial.rotation(degrees)\n//           MotorLeft.spin(forward);\n//           MotorRight.spin(reverse);\n//           while()\n\n          MotorLeft.setPosition(0,turns);\n          MotorLeft.spin(forward);\n          MotorRight.spin(forward);\n          \n          while(OpticalSensor.isNearObject()!=1 || Distance1.objectDistance(mm) > 80){}\n          MotorLeft.stop(brake);\n          MotorRight.stop(brake);\n          Brain.Screen.print(\"ooga booga\");\n\n\n          \n          BrainInertial.rotation(degrees);\n          float max = 0.5;\n          int s = MotorElevator.position(turns);\n          MotorElevator.spin(forward);\n          while (MotorElevator.position(turns)< max+s){}\n          MotorElevator.stop(brake);\n          MotorElevator.stop(hold);\n\n\n          //Brain.Screen.newLine();\n          //Brain.Screen.print(\"Color Check Bin\");\n\n\n          float Colour = colorCheckBin(ObjColour,x);\n\n          wait(2,seconds);\n\n          MotorLeft.spin(forward);\n          MotorRight.spin(forward);\n          while(OpticalSensor.isNearObject()!=1){}\n          MotorLeft.stop(brake);\n          MotorRight.stop(brake);\n\n          dropping (50,x);\n       \n          Brain.Screen.newLine();\n          Brain.Screen.print(\"We dropped\");\n          Brain.Screen.clearLine(1);\n          \n         MotorLeft.stop(brake);\n         MotorRight.stop(brake);\n\n        //  MotorLeft.spin(reverse);\n        //  MotorRight.spin(reverse);\n        //  wait(0.5, seconds);\n        //  MotorLeft.stop(brake);\n        //  MotorRight.stop(brake);\n        \n          if (Colour ==1.0){\n            Brain.Screen.newLine();\n          Brain.Screen.print(\"Orange\");\n            turnPID(180);\n          }\n          else if (Colour==2.0){\n            Brain.Screen.newLine();\n          Brain.Screen.print(\"Blue\");\n            turnPID(90);\n          }\n          else if (Colour == 3.0){\n            Brain.Screen.newLine();\n          Brain.Screen.print(\"GGGreen\");\n            turnPID(-90);\n          }\n          else return 9999;\n\n\n        MotorElevator.spin(reverse);\n        //while(MotorLeft.position(turns) < 1.7 ){}\n        wait(1.2,seconds);\n        MotorElevator.stop();\n        turnCheck = true;\n        \n        MotorLeft.setPosition(0,turns);\n        MotorLeft.spin(forward);\n        MotorRight.spin(forward);\n        \n        while(MotorLeft.position(turns) < 2){}\n        MotorLeft.stop(brake);\n        MotorRight.stop(brake);\n        \n        wait(2,seconds);\n\n        x_pos = 0;\n        y_pos=0;\n\n        \n       MotorLeft.setVelocity(10,percent);\n        MotorRight.setVelocity(10,percent);\n\n\n         if(BrainInertial.rotation(degrees) > 0 ){\n          MotorRight.spin(reverse);\n          MotorLeft.spin(forward   );\n          while(BrainInertial.rotation(degrees) > 2 ){}\n          Brain.Screen.newLine();\n          Brain.Screen.print(\"VEXcode IF\");\n\n\n          MotorLeft.stop();\n          MotorRight.stop();\n          }\n          else if(BrainInertial.rotation(degrees) > 180){\n\n          MotorRight.spin(forward);\n          MotorLeft.spin(reverse);\n          while(BrainInertial.rotation(degrees) < 3 ){}\n           Brain.Screen.newLine();\n          Brain.Screen.print(\"VEXcode IF ELSE\");\n         MotorLeft.stop();\n         MotorRight.stop();\n          }\n         MotorLeft.setVelocity(70,percent);\n         MotorRight.setVelocity(70,percent);\n\n        //while(!touchSensor.pressing()){}\n        //while(touchSensor.pressing()){}\n      // }\n\n  }\n  Brain.playSound(siren);\n  valid = false;\n}\nBrain.programStop();\n}\n}\n","textLanguage":"cpp","robotConfig":[{"port":[7],"name":"MotorLeft","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"MotorRight","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[3],"name":"OpticalSensor","customName":true,"deviceType":"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22},{"port":[2],"name":"MotorGrabber","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"MotorElevator","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[1],"name":"Distance1","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[8],"name":"touchSensor","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}